local MMain = JRequire "Dev.Main.MMain"
local MPlayer = JRequire "Dev.Player.MPlayer"
local HeartBeat = JRequire "Dev.Player.HeartBeat"
local _M = {}

_M.ActivityState = 
{
	Waiting = 1,	--未开始
	Doing = 2,		--进行中
	Finish = 3,		--已结束（显示界面）
	Close = 4,		--关闭（不显示界面）
}

_M.RewardGetState = 
{
	CanNotGet = 2,	--不可领取
	CanGet = 0,		--可领取
	Geted = 1,		--已领取
	Buying = 3,		--订单处理中
}

_M.CharityGetState = 
{
	CanGet = 1, --可领取
	Geted = 2,	--已领取
	CanNotGet = 3,--不能领取
}

_M.AdventureTypeEnum = {
	Person = 1,
	Gang = 2,
}

_M.XinGuanTypeEnum = {
	Gang = 1,
	Personal = 2
}

_M.AdvReqTypeEnum = {
	Gongguan = 1, --公关
	Xingzheng = 2,--行政
	Tech = 3,	  --技术
	Sell = 4,	  --营销
	Sex = 5,	  --性别
	Nationality = 6,--国籍
	Age = 7,		--年龄
	YuanGong = 8,	--员工
	Job = 9,		--职位
	cloth = 10,		--衣服颜色
	tile = 11,		--领带颜色
	glass = 12, 	--戴眼镜
}

_M.AdvSexEnum = {
	Female = 1,	-- 女性
	Man = 2, 	--	男性
}

--全局配置表冲榜活动商会冲榜榜单类型
_M.CommerceRank = {
	[Csv.Const(67)] = true,
	[Csv.Const(85)] = true,
	[Csv.Const(86)] = true,
	[Csv.Const(92)] = true,
}

_M.FuturesState = {
	DEF = 1, -- 未抽取
	CHOU=2, -- 已抽取
	RECHARGE=3 -- 已充值
}

_M.ActList = {}
_M.ActTypeCached = {}
_M.ActRankTypeToID = {}
_M.ActRedpointCached = {}
_M.ActRankQuestTime = {}
_M.XinGuanStatus = {} 				-- 新官上任活动，每日有个时间段，标记每日是否在活动时间段内
_M.IsUpdateTime1 = false 			-- 新官上任，倒计时为0，向后端请求数据标记
_M.IsUpdateTime2 = false 			-- 新官上任，倒计时为0，向后端请求数据标记
_M.ActIdForType = {}				-- 活动类型对应活动ID
_M.LotteryMessage = {}				-- 抽奖消息
_M.LotterySuperGetter = {playerId = 0, playerName = ""}
_M.XinGuanRed = false
_M.SevenDayTargetPageRedIndex = -1	-- 七日目标今日目标页签红点Index
_M.MaxStageNum = tonumber(Csv.Const(20151))
_M.InvestmentRed = false
_M.FuturesSelectIndex = 0 -- 操纵期货 选择的文件
_M.FuturesReward = {} -- 操纵期货中奖信息
_M.AdventureShopRed = false
_M.GloalTravalRed = false
_M.TravalDicsItemId = tonumber(Csv.Const(20158))

function _M.Clean()
	_M.ActList = {}
	_M.ActTypeCached = {}
	_M.ActRankTypeToID = {}
	_M.ActRedpointCached = {}	
	_M.ActRankQuestTime = {}
	_M.ActIdForType = {}
	_M.IsUpdateTime1 = false
	_M.IsUpdateTime2 = false	
	_M.XinGuanStatus = {}
	_M.LotteryMessage = {}
	_M.LotterySuperGetter = {playerId = 0, playerName = ""}
	_M.XinGuanRed = false
	_M.InvestmentRed = false
	_M.FuturesSelectIndex = 0
	_M.FuturesReward = {}
	_M.AdventureShopRed = false
	_M.GloalTravalRed = false
end

function _M.ClearForType(actType)
	local list = _M.ActTypeCached[actType]
	if list ~= nil then
		for k,v in pairs(list) do
			_M.ActList[k] = nil
			_M.ActRedpointCached[k] = nil
		end
		_M.ActTypeCached[actType] = nil
	end
end

function _M.ClearForId(actId)
	if _M.ActList ~= nil and _M.ActList[actId] ~= nil then
		local actType = _M.ActList[actId].actType
		_M.ActList[actId] = nil
		_M.ActRedpointCached[actId] = nil
		if _M.ActTypeCached[actType] ~= nil then
			_M.ActTypeCached[actType][actId] = nil
			if not _M.IsHaveActForType(actType) then
				_M.ActTypeCached[actType] = nil
			end
		end
	end
end

function _M.ClearAll()
	_M.ActList = {}
	_M.ActTypeCached = {}
	_M.ActRankTypeToID = {}
end

function _M.UpdateAct(id, type, info)
	_M.ActList[id] = info
	local tmp = _M.ActTypeCached[type]
	if tmp ~= nil then
		tmp[id] = info
	else
		tmp = {[id] = info}
		_M.ActTypeCached[type] = tmp
	end
	_M.ActIdForType[type] = id

	if info and info.selfRank and info.rankType then
		_M.ActRankTypeToID[info.rankType] = id
	end
end

function _M.ActRedpoint(id, index, needRedpoint)
	local tmp = _M.ActRedpointCached[id]
	if tmp == nil then
		tmp = {[index] = needRedpoint}
		_M.ActRedpointCached[id] = tmp
		return true
	elseif tmp[index] ~= needRedpoint then
		tmp[index] = needRedpoint
		return true
	end
	return false
end

--根据活动ID或活动索引项获取活动红点情况
function _M.IsHaveRedpointForAct(actId, index)
	if actId ~= nil then
		local actRedpoint = _M.ActRedpointCached[actId]
		if actRedpoint ~= nil then	
			if index ~= nil then
				return actRedpoint[index]
			end
			for _, isCanGet in pairs(actRedpoint) do
				if isCanGet then
					return true
				end
			end
		end
		return false
	end
	return false
end

function _M.GetListFromType(actType)
	return _M.ActTypeCached[actType]
end

function _M.GetFromId(actId)
	return _M.ActList[actId]
end

function _M.IsHaveActForType(actType)
	return _M.ActTypeCached[actType] ~= nil and next(_M.ActTypeCached[actType]) ~= nil
end

function _M.SetLastRankTime(id, time)
	if _M.ActRankQuestTime ~= nil then
		_M.ActRankQuestTime[id] = time
	end
end

function _M.GetLastRankTime(id)
	if _M.ActRankQuestTime ~= nil and _M.ActRankQuestTime[id] ~= nil then
		return _M.ActRankQuestTime[id]
	end
	return nil
end

--获取充值奖励切页状态
function _M.GetRechargeOpenFunc()
	local funcs = {}
	local csvLines = Csv.FuncMap[Define.SysId.RechargeReward]
	if csvLines ~= nil and #csvLines > 0 then
		for k,v in pairs(csvLines) do
			if MMain.FuncIsOpen(v.id) then
				if (v.id == Define.SysId.RechargeReward_Day and _M.GetListFromType(Define.ActivityType.RechargeReward_Day) ~= nil) or
					(v.id == Define.SysId.RechargeReward_Total and _M.GetListFromType(Define.ActivityType.RechargeReward_Total) ~= nil) or
					 (v.id == Define.SysId.RechargeReward_TotalDay and _M.GetListFromType(Define.ActivityType.RechargeReward_TotalDay) ~= nil) or
					  (v.id == Define.SysId.RechargeReward_DailyGift and _M.GetListFromType(Define.ActivityType.RechargeReward_DailyGift) ~= nil) or
					  	(v.id == Define.SysId.RechargeReward_Single and _M.GetListFromType(Define.ActivityType.RechargeReward_Single) ~= nil) then
						table.insert(funcs, v)
				end
			end
		end
	end
	if isNeedSort and #funcs > 0 then
		table.sort( funcs, function (a, b)
			return a.sort < b.sort
		end )
	end
	
	return funcs
end

--更新带有榜单类型的活动自己排名数据
function _M.UpdateActivitySelfRank(rankType, selfRank, selfValue)
	if _M.ActRankTypeToID and _M.ActRankTypeToID[rankType] and _M.ActList and 
									 _M.ActList[_M.ActRankTypeToID[rankType]] then
		local actData = _M.ActList[_M.ActRankTypeToID[rankType]]
		if not _M.CommerceRank[rankType] then
			if actData.selfRank and selfRank then
				actData.selfRank = selfRank
			end
			if actData.rankPro and selfValue then
				actData.rankPro = selfValue
			end
		end
	end
end

function _M.UpdatePersonEvent(actId,data)
	if _M.ActList[actId] ~= nil then
		--看下事件是不是满了
		local count = 0
		for k,v in pairs(_M.ActList[actId].personalEventlist) do
			count = count + 1
		end
		if count == Csv.Const(20101)[2] then
			local removeIndex = -1
			for k,v in pairs(_M.ActList[actId].personalEventlist) do
				if removeIndex == -1 then
					removeIndex = v.eventsIndex
				end
				if removeIndex > v.eventsIndex then
					removeIndex = v.eventsIndex
				end
			end
			--移除
			_M.ActList[actId].personalEventlist[removeIndex] = nil
		end
		local event = _M.GetNewPersonEvent(data)
		_M.ActList[actId].personalEventlist[event.eventsIndex] = event
		_M.ActList[actId].nextUpdateTime = data.triggerTime + Csv.Const(20101)[1]
		_M.ActList[actId].isNew = true
	end
end

function _M.UpdateGangEvent(actId,data)
	local isJoin = false
	if _M.ActList[actId] ~= nil then
		for k,v in pairs(data.gangeventlist) do
			local event = _M.GetNewGangEvent(v)
			_M.ActList[actId].shopEventList[event.eventsIndex] = event
			if not _M.AdventureShopRed then
				if event.playerlist ~= nil then
					for i,j in pairs(event.playerlist) do
						if j.playerId == MPlayer.GetId() then
							isJoin = true
						end
					end
				end
				if event.playerInfo.playerId ~= MPlayer.GetId() 
				and event.triggerTime + Csv.Const(20101)[10] > HeartBeat.ServSecond() then
					_M.AdventureShopRed = not isJoin
				end
			end
		end
	end
end

function _M.SetAdvNewFlag(actId,isShow)
	if _M.ActList[actId] ~= nil then
		_M.ActList[actId].isNew = isShow
	end
end

function _M.GetNewPersonEvent(data)
	local eventInfo = {}
	local adventureItemCsv = Csv.AdventureMainEvent[data.eventId]
	if adventureItemCsv == nil then
		error("事件id"..data.eventId.."错误")
		return
	end
	if data.eventInfo ~= nil then
		for i=1, #data.eventInfo do
			local item = {
				index = data.eventInfo[i].index,
				attrInfo = {}
			}
			if data.eventInfo[i].attrInfo ~= nil then
				for k,v in pairs(data.eventInfo[i].attrInfo) do
					local one = {
						type = v.type,
						val = v.value,
						extra = v.extra,
					}
					item.attrInfo[k] = one
				end
				eventInfo[i] = item
			end
		end
	end
	local one = {
		title = adventureItemCsv.title,
		start = adventureItemCsv.start,
		quality = adventureItemCsv.quality,
		desc = adventureItemCsv.desc,
		eventInfo = eventInfo,
		eventId = data.eventId,
		eventsIndex = data.eventsIndex,
	}
	return one
end

function _M.GetNewGangEvent(data)
	local one = {}
	local tplayerlist = {}
	one.eventId = data.eventId
	one.eventsIndex = data.eventsIndex
	one.triggerTime = data.triggerTime
	one.type = data.type --1 进行中的 2是领奖的
	one.playerInfo = {
		icon = data.playerInfo.icon,
		level = data.playerInfo.level,
		power = data.playerInfo.power,
		devote = data.playerInfo.devote,
		job = data.playerInfo.job,
		name = data.playerInfo.name,
		sex = data.playerInfo.sex,
		playerId = data.playerInfo.playerId,
		vip = data.playerInfo.vip,
	}
	if data.playerlist ~= nil then
		for k, v in pairs(data.playerlist) do
			local playerInfo = {
				icon = v.icon,
				level = v.level,
				power = v.power,
				devote = v.devote,
				staffId = v.staffId,
				job = v.job,
				name = v.name,
				sex = v.sex,
				playerId = v.playerId,
				vip = v.vip,
			}
			table.insert(tplayerlist, playerInfo)
		end
	end
	--需求
	if data.eventInfo.attrInfo ~= nil then
		one.eventInfo = {
			--params -1为任意员工，其他为指定员工 不管只读第一个
			type = data.eventInfo.attrInfo[1].type,
			val = data.eventInfo.attrInfo[1].value,
			params = data.eventInfo.attrInfo[1].params,
		}
	end
	one.playerlist = tplayerlist
	return one
end

--获取奇遇已使用员工列表
function _M.GetAdvUseList(actId)
	if _M.ActList[actId] ~= nil then
		return _M.ActList[actId].staffjoinlist
	end
end

--奇遇更新商城数据
function _M.UpdateAdvShop(data)
	local shopData = _M.ActList[data.actId].shop
	if shopData ~= nil then
		for k,v in pairs(shopData.itemList) do
			if v.index == data.index then
				v.buyCount = data.buyCount
				break
			end
		end
	end
end

function _M.RemoveGangEvent(actId,data)
	if _M.ActList[actId] ~= nil then
		_M.ActList[actId].shopEventList[data.eventIndex] = nil
	end
end

--奇遇刷新后商店数据更新
function _M.SetShopAdvData(data)
	_M.ActList[data.actId].shop = data
end

--获取奇遇加班员工列表
function _M.GetAdvOverList(actId)
	if _M.ActList[actId] ~= nil then
		return _M.ActList[actId].staffoverlist
	end
end

function _M.GetFuturesData()
	local typeId = Define.ActivityType.Futures
	local data = _M.GetListFromType(typeId)
	if data == nil then
		return nil
	end
	local activityId = _M.ActIdForType[typeId]
	if data[activityId] == nil then
		return nil
	end
	return data[activityId]
end

-- 环球旅行
function _M.CheckThisItemIsLight(exchangeConf, data, numId)
	local needList = {}
	for k,v in pairs(exchangeConf.diceItems) do
		if needList[v[1]] == nil then
			needList[v[1]] = v[2]
		else
			needList[v[1]] = needList[v[1]] + v[2]
		end
	end

	local count = 0
	local totalNum = 0
	for k,v in pairs(needList) do
		local hasData = data[k]
		local hasCount = (hasData and hasData.count) or 0
		if v <= hasCount then
			count = count + 1
		end

		totalNum = totalNum + 1
	end

	return count ~= totalNum
end

function _M.CheckHasExchange(numberCount)
	local isHas = false
	for k,v in pairs(Csv.GlobalTravalExchange) do
		if not _M.CheckThisItemIsLight(v, numberCount, v.id) then
			isHas = true
			break
		end
	end

	return isHas
end


return _M